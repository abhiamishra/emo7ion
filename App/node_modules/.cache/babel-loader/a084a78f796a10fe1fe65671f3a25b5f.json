{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isTensor3D, isTensor4D } from '../utils';\n/**\r\n * Extracts the tensors of the image regions containing the detected faces.\r\n * Useful if you want to compute the face descriptors for the face images.\r\n * Using this method is faster then extracting a canvas for each face and\r\n * converting them to tensors individually.\r\n *\r\n * @param imageTensor The image tensor that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns Tensors of the corresponding image region for each detected face.\r\n */\n\nexport function extractFaceTensors(imageTensor, detections) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\n        throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\n      }\n\n      if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\n        throw new Error('extractFaceTensors - batchSize > 1 not supported');\n      }\n\n      return [2\n      /*return*/\n      , tf.tidy(function () {\n        var _a = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0),\n            imgHeight = _a[0],\n            imgWidth = _a[1],\n            numChannels = _a[2];\n\n        var boxes = detections.map(function (det) {\n          return det instanceof FaceDetection ? det.forSize(imgWidth, imgHeight).box : det;\n        }).map(function (box) {\n          return box.clipAtImageBorders(imgWidth, imgHeight);\n        });\n        var faceTensors = boxes.map(function (_a) {\n          var x = _a.x,\n              y = _a.y,\n              width = _a.width,\n              height = _a.height;\n          return tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);\n        });\n        return faceTensors;\n      })];\n    });\n  });\n}","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,EAAZ,MAAoB,uBAApB;AAGA,SAASC,aAAT,QAA8B,0BAA9B;AACA,SAASC,UAAT,EAAqBC,UAArB,QAAuC,UAAvC;AAEA;;;;;;;;;;;AAUA,OAAM,SAAgBC,kBAAhB,CACJC,WADI,EAEJC,UAFI,EAEmC;;;AAGvC,UAAI,CAACJ,UAAU,CAACG,WAAD,CAAX,IAA4B,CAACF,UAAU,CAACE,WAAD,CAA3C,EAA0D;AACxD,cAAM,IAAIE,KAAJ,CAAU,2DAAV,CAAN;AACD;;AAED,UAAIJ,UAAU,CAACE,WAAD,CAAV,IAA2BA,WAAW,CAACG,KAAZ,CAAkB,CAAlB,IAAuB,CAAtD,EAAyD;AACvD,cAAM,IAAID,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED;AAAA;AAAA,QAAOP,EAAE,CAACS,IAAH,CAAQ;AACP;AAAA,YAACC,iBAAD;AAAA,YAAYC,gBAAZ;AAAA,YAAsBC,mBAAtB;;AAEN,YAAMC,KAAK,GAAGP,UAAU,CAACQ,GAAX,CACZ,eAAG;AAAI,oBAAG,YAAYb,aAAf,GACHc,GAAG,CAACC,OAAJ,CAAYL,QAAZ,EAAsBD,SAAtB,EAAiCO,GAD9B,GAEHF,GAFG;AAEA,SAHK,EAKXD,GALW,CAKP,eAAG;AAAI,oBAAG,CAACI,kBAAJ,CAAuBP,QAAvB,EAAiCD,SAAjC;AAA2C,SAL3C,CAAd;AAOA,YAAMS,WAAW,GAAGN,KAAK,CAACC,GAAN,CAAU,UAACM,EAAD,EAAwB;cAArBC;cAAGC;cAAGC;cAAOC;AAC5C,mBAAE,CAACC,OAAH,CAAWpB,WAAW,CAACqB,IAAZ,CAAiBhB,SAAjB,EAA4BC,QAA5B,EAAsCC,WAAtC,CAAX,EAA+D,CAACU,CAAD,EAAID,CAAJ,EAAO,CAAP,CAA/D,EAA0E,CAACG,MAAD,EAASD,KAAT,EAAgBX,WAAhB,CAA1E;AAAuG,SADrF,CAApB;AAIA,eAAOO,WAAP;AACD,OAfM,CAAP;;;AAgBD","names":["tf","FaceDetection","isTensor3D","isTensor4D","extractFaceTensors","imageTensor","detections","Error","shape","tidy","imgHeight","imgWidth","numChannels","boxes","map","det","forSize","box","clipAtImageBorders","faceTensors","_a","x","y","width","height","slice3d","as3D"],"sources":["../../../src/dom/extractFaceTensors.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}