{"ast":null,"code":"import { minBbox } from '../ops';\nimport { getCenterPoint } from '../utils';\nimport { Box } from './Box';\nimport { Dimensions } from './Dimensions';\nimport { FaceDetection } from './FaceDetection';\nimport { Point } from './Point';\nimport { Rect } from './Rect'; // face alignment constants\n\nvar relX = 0.5;\nvar relY = 0.43;\nvar relScale = 0.45;\n\nvar FaceLandmarks =\n/** @class */\nfunction () {\n  function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\n    if (shift === void 0) {\n      shift = new Point(0, 0);\n    }\n\n    var width = imgDims.width,\n        height = imgDims.height;\n    this._imgDims = new Dimensions(width, height);\n    this._shift = shift;\n    this._positions = relativeFaceLandmarkPositions.map(function (pt) {\n      return pt.mul(new Point(width, height)).add(shift);\n    });\n  }\n\n  Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\n    get: function () {\n      return new Point(this._shift.x, this._shift.y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\n    get: function () {\n      return this._imgDims.width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\n    get: function () {\n      return this._imgDims.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\n    get: function () {\n      return this._positions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\n    get: function () {\n      var _this = this;\n\n      return this._positions.map(function (pt) {\n        return pt.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight));\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FaceLandmarks.prototype.forSize = function (width, height) {\n    return new this.constructor(this.relativePositions, {\n      width: width,\n      height: height\n    });\n  };\n\n  FaceLandmarks.prototype.shiftBy = function (x, y) {\n    return new this.constructor(this.relativePositions, this._imgDims, new Point(x, y));\n  };\n\n  FaceLandmarks.prototype.shiftByPoint = function (pt) {\n    return this.shiftBy(pt.x, pt.y);\n  };\n  /**\r\n   * Aligns the face landmarks after face detection from the relative positions of the faces\r\n   * bounding box, or it's current shift. This function should be used to align the face images\r\n   * after face detection has been performed, before they are passed to the face recognition net.\r\n   * This will make the computed face descriptor more accurate.\r\n   *\r\n   * @param detection (optional) The bounding box of the face or the face detection result. If\r\n   * no argument was passed the position of the face landmarks are assumed to be relative to\r\n   * it's current shift.\r\n   * @returns The bounding box of the aligned face.\r\n   */\n\n\n  FaceLandmarks.prototype.align = function (detection, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (detection) {\n      var box = detection instanceof FaceDetection ? detection.box.floor() : new Box(detection);\n      return this.shiftBy(box.x, box.y).align(null, options);\n    }\n\n    var _a = Object.assign({}, {\n      useDlibAlignment: false,\n      minBoxPadding: 0.2\n    }, options),\n        useDlibAlignment = _a.useDlibAlignment,\n        minBoxPadding = _a.minBoxPadding;\n\n    if (useDlibAlignment) {\n      return this.alignDlib();\n    }\n\n    return this.alignMinBbox(minBoxPadding);\n  };\n\n  FaceLandmarks.prototype.alignDlib = function () {\n    var centers = this.getRefPointsForAlignment();\n    var leftEyeCenter = centers[0],\n        rightEyeCenter = centers[1],\n        mouthCenter = centers[2];\n\n    var distToMouth = function (pt) {\n      return mouthCenter.sub(pt).magnitude();\n    };\n\n    var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\n    var size = Math.floor(eyeToMouthDist / relScale);\n    var refPoint = getCenterPoint(centers); // TODO: pad in case rectangle is out of image bounds\n\n    var x = Math.floor(Math.max(0, refPoint.x - relX * size));\n    var y = Math.floor(Math.max(0, refPoint.y - relY * size));\n    return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\n  };\n\n  FaceLandmarks.prototype.alignMinBbox = function (padding) {\n    var box = minBbox(this.positions);\n    return box.pad(box.width * padding, box.height * padding);\n  };\n\n  FaceLandmarks.prototype.getRefPointsForAlignment = function () {\n    throw new Error('getRefPointsForAlignment not implemented by base class');\n  };\n\n  return FaceLandmarks;\n}();\n\nexport { FaceLandmarks };","map":{"version":3,"mappings":"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","names":["minBbox","getCenterPoint","Box","Dimensions","FaceDetection","Point","Rect","relX","relY","relScale","relativeFaceLandmarkPositions","imgDims","shift","height","_imgDims","width","_shift","_positions","map","mul","add","Object","FaceLandmarks","x","y","sub","_this","div","imageWidth","imageHeight","constructor","relativePositions","pt","shiftBy","detection","options","box","floor","align","useDlibAlignment","minBoxPadding","alignDlib","alignMinBbox","centers","getRefPointsForAlignment","rightEyeCenter","mouthCenter","distToMouth","magnitude","eyeToMouthDist","leftEyeCenter","size","Math","refPoint","max","min","padding","positions","pad","Error"],"sources":["../../../src/classes/FaceLandmarks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}